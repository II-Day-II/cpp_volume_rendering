#version 430
// volume variables
layout (binding = 1) uniform sampler3D TexVolume; 
layout (binding = 2) uniform sampler3D TexVolumeGradient;

uniform vec3 VolumeGridResolution;
uniform vec3 VolumeVoxelSize;
uniform vec3 VolumeGridSize;

// camera variables
uniform vec3 CameraEye;

uniform mat4 u_CameraLookAt;
uniform mat4 ProjectionMatrix;

uniform float u_TanCameraFovY;
uniform float u_CameraAspectRatio;

// traversal variables
uniform float Isovalue;
uniform float StepSize;

uniform vec3 VolumeScales;

// shading variables
uniform vec4 Color;
uniform int ApplyGradientPhongShading;

uniform float BlinnPhongKa;
uniform float BlinnPhongKd;
uniform float BlinnPhongKs;
uniform float BlinnPhongShininess;

uniform vec3 BlinnPhongIspecular;

uniform vec3 WorldEyePos;
uniform vec3 LightSourcePosition;

// compute data
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba16f, binding = 0) uniform image2D OutputFrag;

// adaptive variables
uniform bool IsFirstPass;
uniform sampler2D tempTexture;

uniform bool DoInterpolation;
uniform int interval;
uniform float maxPixelDifference;
uniform bool visualize_pixel_difference;
uniform bool use_luminance_difference;

//////////////////////////////////////////////////////////////////////////////////////////////////
// From structured/_common_shaders/ray_bbox_intersection.comp
struct Ray { vec3 Origin; vec3 Dir; };
bool RayAABBIntersection (vec3 vert_eye, vec3 vert_dir, vec3 vol_scaled_dim,
                          out Ray r, out float rtnear, out float rtfar);
//////////////////////////////////////////////////////////////////////////////////////////////////

vec3 ShadeBlinnPhong (vec3 Tpos, vec3 clr)
{
  // Gradient normal
  vec3 gradient_normal =  texture(TexVolumeGradient, Tpos / VolumeGridSize).xyz;
  
  // If is non-zero
  if (gradient_normal != vec3(0, 0, 0))
  {
    vec3 Wpos = Tpos - (VolumeGridSize * 0.5);
    
    vec3 light_direction = normalize(LightSourcePosition - Wpos);
    vec3 eye_direction   = normalize(CameraEye - Wpos);
    vec3 halfway_vector  = normalize(eye_direction + light_direction);
  
    gradient_normal      = normalize(gradient_normal);
    // We consider front and back faces as the same
    // float FrontOrBack = dot(gradient_normal, eye_direction);
    // if (FrontOrBack < 0)
    // {
    //   gradient_normal = -gradient_normal;
    // }
    
    // float dot_diff = dot(gradient_normal, light_direction);
    // if (dot_diff < 0) dot_diff = dot(-gradient_normal, light_direction);
    float dot_diff = max(0, dot(gradient_normal, light_direction));

    // float dot_spec = dot(halfway_vector, gradient_normal);
    // if (dot_spec < 0) dot_spec = dot(halfway_vector, -gradient_normal);
    float dot_spec = max(0, dot(halfway_vector, gradient_normal));
   
    clr = 
      // rgb only affects ambient + diffuse
      (clr * (BlinnPhongKa + BlinnPhongKd * dot_diff)) 
      // specular contribution has it's own color
      + BlinnPhongIspecular * BlinnPhongKs * pow(dot_spec, BlinnPhongShininess)
    ;
  }

  return clr;
}

struct RaycastRequirements {
    float tnear;
    float tfar;
    Ray r;
};


void EvalPixel(RaycastRequirements raycastInfo, ivec2 storePos)
{
      float tnear = raycastInfo.tnear;
      float tfar = raycastInfo.tfar;
      Ray r = raycastInfo.r;
      // Distance to be evaluated
      float D = abs(tfar - tnear);

      // Initialize Transparency and Radiance color
      vec4 dst = vec4(0.0);

      // World position at tnear, translated to the volume [0, VolumeGridSize]
      vec3 wld_pos = r.Origin + r.Dir * tnear;
      // Texture position
      vec3 tex_pos = wld_pos + (VolumeGridSize * 0.5);
      
      // Evaluate from 0 to D...
      float prevDensity = texture(TexVolume, tex_pos / VolumeGridSize).r;
      for(float s = 0.0; s < D;)
      {
        // Get the current step or the remaining interval
        float h = min(StepSize /*0.5*/, D - s);
      
        // Texture position at tnear + (s + h)
        vec3 s_tex_pos = tex_pos  + r.Dir * (s + h);
      
        // Get normalized density from volume
        float density = texture(TexVolume, s_tex_pos / VolumeGridSize).r;

        // First hit: isosurface
        if ( (prevDensity <= Isovalue && Isovalue < density)
          || (prevDensity >= Isovalue && Isovalue > density) )
        {
          //refine position
          float t = (Isovalue - prevDensity) / (density - prevDensity);
          s_tex_pos = tex_pos  + r.Dir * (s + t * h);
          
          // Get color
          vec4 src = Color; //vec4(0.2, 0.2, 0.9, 1.0);

          // Apply gradient, if enabled
          if (ApplyGradientPhongShading == 1)
          {
            src.rgb = ShadeBlinnPhong(s_tex_pos, src.rgb);
          }

          // Front-to-back composition
          src.rgb = src.rgb * src.a;
          dst = dst + (1.0 - dst.a) * src;
          
          // Opacity threshold: 99%
          if (dst.a > 0.99) break;
        }

        // Go to the next interval
        prevDensity = density;
        s = s + h;
      }
      imageStore(OutputFrag, storePos, dst);
}

bool IsDone(vec2 pos)
{
    vec2 size = imageSize(OutputFrag);
    return 
        // in bounds
        pos.x >= 0
        && pos.x < size.x
        && pos.y >= 0 
        && pos.y < size.y
        // on grid
        && mod(floor(pos.x), interval) == 0
        && mod(floor(pos.y), interval) == 0;
}
vec2 AddToAvgIfValid(float x, vec2 s)
{
    if (x != -1)
        return vec2(s.x + x, s.y + 1);
    return s;
}

float AddToSumIfValid(float x, float avg)
{
    if (x != -1)
        return pow(x - avg, 2);
    return 0;
}

float stdDev(float a, float b, float c, float d)
{
    vec2 sumAmount = AddToAvgIfValid(a, vec2(0));
    sumAmount += AddToAvgIfValid(b, sumAmount);
    sumAmount += AddToAvgIfValid(c, sumAmount);
    sumAmount += AddToAvgIfValid(d, sumAmount);

    float amount = sumAmount.y;
    float avg = sumAmount.x / amount;

    float sum = AddToSumIfValid(a, avg);
    sum += AddToSumIfValid(b, avg);
    sum += AddToSumIfValid(c, avg);
    sum += AddToSumIfValid(d, avg);

    return sqrt(sum / (amount - 1));
}


vec4 pixelDifferenceStdDev(vec2 tr, vec2 tl, vec2 br, vec2 bl)
{
     // colors
    vec4 trc, tlc, brc, blc;
    // validities
    bool trd, tld, brd, bld;
    trd = IsDone(tr);
    tld = IsDone(tl);
    brd = IsDone(br);
    bld = IsDone(bl);
    if (trd)
    {
        trc = texture(tempTexture, tr);
    } else trc = vec4(-1);
    if (tld)
    {
        tlc = texture(tempTexture, tl);
    } else tlc = vec4(-1);
    if (brd)
    {
        brc = texture(tempTexture, br);
    } else brc = vec4(-1);
    if (bld)
    {
        blc = texture(tempTexture, bl);
    } else blc = vec4(-1);
 
    return vec4(
        stdDev(trc.r, tlc.r, brc.r, blc.r) 
        , stdDev(trc.g, tlc.g, brc.g, blc.g)
        , stdDev(trc.b, tlc.b, brc.b, blc.b)
        , stdDev(trc.a, tlc.a, brc.a, blc.a)
    );
}
bool PixelDifferenceStdDevOk(vec2 tr, vec2 tl, vec2 br, vec2 bl)
{
    vec4 diffs = pixelDifferenceStdDev(tr, tl, br, bl);
    return diffs.r < maxPixelDifference
        && diffs.g < maxPixelDifference
        && diffs.b < maxPixelDifference
        && diffs.a < maxPixelDifference;
}
vec4 pixelDifferenceLuminance(vec2 tr, vec2 tl, vec2 br, vec2 bl)
{
    vec4 luminance_weights = vec4(0.2126, 0.7152, 0.0722, 0.0);
    // colors
    vec4 trc, tlc, brc, blc;
    // validities
    bool trd, tld, brd, bld;
    // luminances
    float trl, tll, brl, bll;
    trd = IsDone(tr);
    tld = IsDone(tl);
    brd = IsDone(br);
    bld = IsDone(bl);
    trc = texture(tempTexture, tr);
    tlc = texture(tempTexture, tl);
    brc = texture(tempTexture, br);
    blc = texture(tempTexture, bl);
    trl = trd ? dot(trc, luminance_weights) : -1;
    tll = tld ? dot(tlc, luminance_weights) : -1;
    brl = brd ? dot(brc, luminance_weights) : -1;
    bll = bld ? dot(blc, luminance_weights) : -1;

    return vec4(
        stdDev(trl, tll, brl, bll)   
    );
}
bool PixelDifferenceLuminanceOk(vec2 tr, vec2 tl, vec2 br, vec2 bl)
{    
    return pixelDifferenceLuminance(tr, tl, br, bl).r < maxPixelDifference;
}

vec4 Interpolate(vec2 left, vec2 right, float t)
{
    vec4 col = vec4(0);
    bool leftExists = IsDone(left);
    bool rightExists = IsDone(right);
    if (leftExists)
    {
        col = texture(tempTexture, left);
        if (rightExists)
        {
            col *= t;
            col += texture(tempTexture, right) * (1 - t);
        }
        return col;
    }
    if (rightExists)
    {
        col = texture(tempTexture, right);
    }
    return col;
}

vec4 PixelDifference(vec2 tr, vec2 tl, vec2 br, vec2 bl)
{
    if (use_luminance_difference)
    {
        return pixelDifferenceLuminance(tr, tl, br, bl);
    }
    else
    {
        return pixelDifferenceStdDev(tr, tl, br, bl);
    }
}

bool PixelDifferenceOk(vec2 tr, vec2 tl, vec2 br, vec2 bl)
{
    if (use_luminance_difference)
    {
        return PixelDifferenceLuminanceOk(tr, tl, br, bl);
    }
    else
    {
        return PixelDifferenceStdDevOk(tr, tl, br, bl);
    }
}

void InterpolateColor(ivec2 storePos, vec2 uv, vec4 size, RaycastRequirements raycastInfo)
{
    // find where to sample neighboring pixels
    vec2 pos = uv * size.zw;
    float xrem = mod(floor(pos.x), interval);//storePos.x % interval;
    float yrem = mod(floor(pos.y), interval);//storePos.y % interval;


    // top right
    vec2 tr = uv + vec2(size.x * (interval - xrem),
                        size.y * (interval - yrem));
    // top left
    vec2 tl = uv + vec2(-size.x * xrem,
                        size.y * (interval - yrem));
    // bot right
    vec2 br = uv + vec2(size.x * (interval - xrem),
                        -size.y * yrem);
    // bot left
    vec2 bl = uv - vec2(size.x * xrem, 
                        size.y * yrem);

    if (visualize_pixel_difference)
    {
        imageStore(OutputFrag, storePos, PixelDifference(tr, tl, br, bl));
        return;
    }
    // check coherence and raycast if not good enough
    if (!PixelDifferenceOk(tr, tl, br, bl))
    {
        EvalPixel(raycastInfo, storePos);
        return;
    }

    // manually Interpolate
    float xa = xrem / interval;
    float ya = yrem / interval;
   
    vec4 bot = Interpolate(br, bl, xa);
    vec4 top = Interpolate(tr, tl, xa);

    vec4 col = mix(bot, top, ya);
    imageStore(OutputFrag, storePos, col);
}

#define RAYCAST 0
#define INTERPOLATE 1
#define SKIP 2
int EvaluationMode(ivec2 storePos)
{
    // always raycast if interpolation is turned off. 
    if (!DoInterpolation)
    {
        return RAYCAST;
    }
    // is this pixel on of the n:th that should be raycast?
    bool onGrid = storePos.x % interval == 0 && storePos.y % interval == 0;
    // raycast if it's the first pass and it should be raycast
    if (onGrid && IsFirstPass)
    {
        return RAYCAST;
    }
    // if we're not on grid in the second pass, interpolate
    if (!onGrid && !IsFirstPass)
    {
        return INTERPOLATE;
    }
    // if we're going to interpolate in the next pass or have already raycast this pixel, don't do anything with it now
    return SKIP;
}

void main ()
{
  ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 size = imageSize(OutputFrag);
  if (storePos.x < size.x && storePos.y < size.y)
  {
    // Get screen position [x, y] and consider centering the pixel by + 0.5
    vec2 fpos = vec2(storePos) + 0.5;

    // Transform fpos from [w, h] to [0, 1] to [-1, 1]
    vec3 VerPos = (vec3(fpos.x / float(size.x), fpos.y / float(size.y), 0.0) * 2.0) - 1.0;

    // Camera direction
    vec3 camera_dir = normalize(vec3(VerPos.x * u_TanCameraFovY * u_CameraAspectRatio, VerPos.y * u_TanCameraFovY, -1.0) * mat3(u_CameraLookAt));

    // Find Ray Intersection
    Ray r; float tnear, tfar;
    bool inbox = RayAABBIntersection(CameraEye, camera_dir, VolumeGridSize, r, tnear, tfar);

    // If inside volume grid
    if(inbox)
    {
      RaycastRequirements raycastInfo;
      raycastInfo.tnear = tnear;
      raycastInfo.tfar = tfar;
      raycastInfo.r = r;
      int evaluation_mode = EvaluationMode(storePos);
      if (evaluation_mode == RAYCAST)
      {
        EvalPixel(raycastInfo, storePos);
      }
      else if (evaluation_mode == INTERPOLATE)
      {
        vec4 size = vec4(1.0/size, size);
        InterpolateColor(storePos, VerPos.xy/2 + 0.5, size, raycastInfo);
      }
      else if (!IsFirstPass) {
        vec4 samp = texture(tempTexture, VerPos.xy/2 + 0.5);
        imageStore(OutputFrag, storePos, samp);
      }
    }
  }
}